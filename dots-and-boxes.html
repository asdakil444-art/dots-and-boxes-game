<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dots and Boxes - Customizable</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #ec4899;
            --bg-gradient: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            --glass-bg: rgba(255, 255, 255, 0.1);
            --glass-border: rgba(255, 255, 255, 0.2);
            --card-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        body {
            font-family: 'Outfit', 'Segoe UI', system-ui, sans-serif;
            background: var(--bg-gradient);
            color: #f8fafc;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            overflow-x: hidden;
        }

        .game-container {
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: 40px;
            box-shadow: var(--card-shadow);
            text-align: center;
            max-width: 950px;
            width: 100%;
            position: relative;
        }

        h1 {
            color: #fff;
            margin-bottom: 8px;
            font-size: 3em;
            font-weight: 800;
            letter-spacing: -0.025em;
            background: linear-gradient(to right, #818cf8, #f472b6);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #94a3b8;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .settings-toggle-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--glass-bg);
            border: 1px solid var(--glass-border);
            color: white;
            width: 45px;
            height: 45px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 100;
        }

        .settings-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: rotate(45deg);
        }

        .settings-panel {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--glass-border);
            border-radius: 18px;
            padding: 25px;
            margin-bottom: 25px;
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
            max-height: 1000px;
            opacity: 1;
        }

        .settings-panel.collapsed {
            max-height: 0;
            margin-bottom: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
            pointer-events: none;
        }

        .player-settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            border: 1px solid var(--glass-border);
        }

        .player-settings.player1 {
            background: rgba(255, 0, 0, 0.05);
            border-color: rgba(255, 0, 0, 0.3);
        }

        .player-settings.player2 {
            background: rgba(0, 0, 255, 0.05);
            border-color: rgba(0, 0, 255, 0.3);
        }

        .player-settings h3 {
            margin-bottom: 5px;
            font-size: 1.1em;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 5px;
        }

        .setting-group label {
            font-size: 0.85em;
            color: #94a3b8;
            font-weight: 600;
        }

        .setting-group input[type="text"] {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: white;
            font-size: 0.9em;
            transition: border-color 0.3s;
        }

        .setting-group input[type="text"]:focus {
            outline: none;
            border-color: var(--primary);
        }

        .setting-group input[type="color"] {
            width: 100%;
            height: 35px;
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            cursor: pointer;
            background: none;
        }

        .score-board {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .player-score {
            padding: 15px 30px;
            border-radius: 16px;
            font-size: 1.4em;
            font-weight: 700;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 160px;
            border: 2px solid transparent;
            position: relative;
        }

        .player-score.active {
            transform: scale(1.05) translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.4);
            z-index: 10;
        }

        .player-score.active::after {
            content: 'YOUR TURN';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.5em;
            background: currentColor;
            padding: 2px 8px;
            border-radius: 4px;
            color: #fff;
            white-space: nowrap;
        }

        .turn-indicator {
            display: none;
            /* Hidden on desktop */
        }

        .game-board {
            display: inline-block;
            position: relative;
            background: rgba(255, 255, 255, 0.03);
            padding: 24px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
        }

        #gameCanvas {
            display: block;
            cursor: crosshair;
            border-radius: 12px;
        }

        .controls {
            margin-top: 25px;
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 30px;
            font-size: 1em;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .btn-apply,
        .btn-new-game {
            font-weight: 600;
            letter-spacing: 0.025em;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .btn-new-game {
            background: linear-gradient(135deg, #6366f1 0%, #a855f7 100%);
            color: white;
        }

        .btn-new-game:hover {
            opacity: 0.9;
            transform: scale(1.02);
        }

        .btn-apply {
            background: #10b981;
            color: white;
        }

        .btn-apply:hover {
            background: #059669;
            transform: translateY(-2px);
        }

        @keyframes boxPop {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }

            50% {
                transform: scale(1.1);
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .box-pop-animation {
            animation: boxPop 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @media (max-width: 600px) {
            .game-container {
                padding: 20px 15px;
                border-radius: 0;
            }

            h1 {
                font-size: 2em;
            }

            .settings-toggle-btn {
                top: 15px;
                right: 15px;
                width: 40px;
                height: 40px;
            }

            .score-board {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 20px;
            }

            .player-score {
                padding: 10px 15px;
                font-size: 1.2em;
                min-width: 120px;
            }

            .settings-panel {
                gap: 15px;
                padding: 15px;
            }

            .player-settings {
                width: 100%;
                min-width: auto;
            }

            .game-board {
                padding: 10px;
                width: 100%;
                box-sizing: border-box;
            }

            #gameCanvas {
                width: 100% !important;
                height: auto !important;
                touch-action: none;
                /* Prevent scrolling while playing */
            }

            .controls button {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        /* Styles for additional players */
        .player-settings.player3 {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #00cc00;
        }

        .player-settings.player4 {
            background: rgba(255, 255, 0, 0.1);
            border: 2px solid #cccc00;
        }
    </style>
</head>

<body>
    <div class="game-container">
        <button class="settings-toggle-btn" onclick="toggleSettings()" title="Settings">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="3"></circle>
                <path
                    d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                </path>
            </svg>
        </button>

        <h1>ðŸŽ® Dots & Boxes</h1>
        <p class="subtitle">Connect dots to complete squares!</p>

        <div class="settings-panel collapsed" id="settingsPanel">
            <div style="width: 100%; text-align: center; margin-bottom: 5px;">
                <label style="font-weight: bold; margin-right: 10px; color: #94a3b8;">Number of Players:</label>
                <select id="numPlayersSelect" onchange="updatePlayerCount()"
                    style="padding: 8px; font-size: 1em; border-radius: 8px; background: rgba(255,255,255,0.1); color: white; border: 1px solid var(--glass-border);">
                    <option value="2">2 Players (10x10 Grid)</option>
                    <option value="3">3 Players (11x11 Grid)</option>
                    <option value="4">4 Players (12x12 Grid)</option>
                </select>
            </div>

            <div class="player-settings player1" id="p1Settings">
                <h3>ðŸ”´ Player 1</h3>
                <div class="setting-group">
                    <label>Team Name:</label>
                    <input type="text" id="player1Name" value="Red" placeholder="Enter team name">
                </div>
                <div class="setting-group">
                    <label>Color:</label>
                    <input type="color" id="player1Color" value="#c62828">
                </div>
            </div>

            <div class="player-settings player2" id="p2Settings">
                <h3>ðŸ”µ Player 2</h3>
                <div class="setting-group">
                    <label>Team Name:</label>
                    <input type="text" id="player2Name" value="Blue" placeholder="Enter team name">
                </div>
                <div class="setting-group">
                    <label>Color:</label>
                    <input type="color" id="player2Color" value="#1565c0">
                </div>
            </div>

            <div class="player-settings player3" id="p3Settings" style="display: none;">
                <h3>ðŸŸ¢ Player 3</h3>
                <div class="setting-group">
                    <label>Team Name:</label>
                    <input type="text" id="player3Name" value="Green" placeholder="Enter team name">
                </div>
                <div class="setting-group">
                    <label>Color:</label>
                    <input type="color" id="player3Color" value="#2e7d32">
                </div>
            </div>

            <div class="player-settings player4" id="p4Settings" style="display: none;">
                <h3>ðŸŸ¡ Player 4</h3>
                <div class="setting-group">
                    <label>Team Name:</label>
                    <input type="text" id="player4Name" value="Yellow" placeholder="Enter team name">
                </div>
                <div class="setting-group">
                    <label>Color:</label>
                    <input type="color" id="player4Color" value="#fbc02d">
                </div>
            </div>
        </div>

        <div class="controls" style="margin-bottom: 20px;">
            <button class="btn-apply" onclick="applySettings()">âœ“ Apply Changes</button>
        </div>

        <div class="score-board" id="scoreBoard">
            <div class="player-score" id="player1Score">
                <span id="player1DisplayName">Red</span>: <span id="player1ScoreValue">0</span>
            </div>
            <div class="player-score" id="player2Score">
                <span id="player2DisplayName">Blue</span>: <span id="player2ScoreValue">0</span>
            </div>
        </div>

        <div class="turn-indicator" id="turnIndicator">
            Red's Turn
        </div>

        <div class="game-board">
            <canvas id="gameCanvas" width="500" height="500" style="width: 500px; height: 500px;"></canvas>
        </div>

        <div class="controls">
            <button class="btn-new-game" onclick="resetGame()">ðŸ”„ New Game</button>
        </div>
    </div>

    <div class="winner-modal" id="winnerModal">
        <div class="winner-content" id="winnerContent">
            <h2 id="winnerText">Red Wins!</h2>
            <p class="final-score" id="finalScore">Red: 25 - Blue: 20</p>
            <button class="btn-new-game" onclick="resetGame(); closeModal();">Play Again</button>
        </div>
    </div>

    <script>
        let GRID_SIZE = 10;
        const SPACING = 50;
        const PADDING = 25;
        const DOT_RADIUS = 6;
        const LINE_WIDTH = 6;
        const LINE_HIT_WIDTH = 30; // Increased hit area for touch

        let currentPlayer = 0; // 0 = player1, 1 = player2, etc.
        let numPlayers = 2;
        let scores = [0, 0];
        let horizontalLines = [];
        let verticalLines = [];
        let boxes = [];
        let canvas, ctx;
        let hoveredLine = null;

        // Player settings
        let players = [
            { name: 'Red', color: '#c62828', bgColor: 'rgba(198, 40, 40, 0.3)' },
            { name: 'Blue', color: '#1565c0', bgColor: 'rgba(21, 101, 192, 0.3)' },
            { name: 'Green', color: '#2e7d32', bgColor: 'rgba(46, 125, 50, 0.3)' },
            { name: 'Yellow', color: '#fbc02d', bgColor: 'rgba(251, 192, 45, 0.3)' }
        ];

        function initGame() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');

            // Set Grid Size based on players
            if (numPlayers === 2) GRID_SIZE = 10;
            else if (numPlayers === 3) GRID_SIZE = 11;
            else if (numPlayers === 4) GRID_SIZE = 12;

            // Resize canvas
            const canvasSize = (GRID_SIZE - 1) * SPACING + (PADDING * 2);
            canvas.width = canvasSize;
            canvas.height = canvasSize;
            canvas.style.width = canvasSize + 'px';
            canvas.style.height = canvasSize + 'px';

            // Initialize arrays
            horizontalLines = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE - 1).fill(null));
            verticalLines = Array(GRID_SIZE - 1).fill(null).map(() => Array(GRID_SIZE).fill(null));
            boxes = Array(GRID_SIZE - 1).fill(null).map(() => Array(GRID_SIZE - 1).fill(null));

            // Add event listeners (Mouse & Touch)
            // Remove old listeners to avoid duplicates if re-initializing
            const content = canvas.parentElement;
            const newCanvas = canvas.cloneNode(true);
            canvas.parentNode.replaceChild(newCanvas, canvas);
            canvas = newCanvas;
            ctx = canvas.getContext('2d');

            canvas.addEventListener('mousemove', handleInputMove);
            canvas.addEventListener('mousedown', handleInputDown);
            canvas.addEventListener('touchstart', handleInputDown, { passive: false });
            canvas.addEventListener('touchmove', handleInputMove, { passive: false });

            canvas.addEventListener('mouseleave', () => {
                hoveredLine = null;
                draw();
            });

            updateDisplay();
            draw();
        }

        function updatePlayerCount() {
            const select = document.getElementById('numPlayersSelect');
            const count = parseInt(select.value);

            // Show/Hide settings panels
            document.getElementById('p3Settings').style.display = count >= 3 ? 'flex' : 'none';
            document.getElementById('p4Settings').style.display = count >= 4 ? 'flex' : 'none';
        }

        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            panel.classList.toggle('collapsed');
        }

        function applySettings() {
            const select = document.getElementById('numPlayersSelect');
            numPlayers = parseInt(select.value);

            // Get values from inputs for active players
            for (let i = 0; i < numPlayers; i++) {
                const nameInput = document.getElementById(`player${i + 1}Name`);
                const colorInput = document.getElementById(`player${i + 1}Color`);

                players[i].name = nameInput.value || `Player ${i + 1}`;
                players[i].color = colorInput.value;
                players[i].bgColor = hexToRgba(players[i].color, 0.3);
            }

            // Reset game with new settings
            resetGame();
            // Automatically collapse on mobile after applying
            if (window.innerWidth <= 600) {
                toggleSettings();
            }
        }

        function hexToRgba(hex, alpha) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        function updateDisplay() {
            const scoreBoard = document.getElementById('scoreBoard');
            scoreBoard.innerHTML = ''; // Clear existing scores

            // Generate score elements for active players
            for (let i = 0; i < numPlayers; i++) {
                const scoreDiv = document.createElement('div');
                scoreDiv.className = 'player-score';
                scoreDiv.id = `player${i + 1}Score`;

                scoreDiv.style.backgroundColor = players[i].bgColor;
                scoreDiv.style.color = players[i].color;
                scoreDiv.style.border = `3px solid ${players[i].color}`;

                if (i === currentPlayer) {
                    scoreDiv.classList.add('active');
                }

                scoreDiv.innerHTML = `${players[i].name}: <span id="player${i + 1}ScoreValue">${scores[i]}</span>`;
                scoreBoard.appendChild(scoreDiv);
            }

            // Update turn indicator
            updateTurnIndicator();
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw completed boxes
            for (let row = 0; row < GRID_SIZE - 1; row++) {
                for (let col = 0; col < GRID_SIZE - 1; col++) {
                    if (boxes[row][col] !== null) {
                        const x = PADDING + col * SPACING + SPACING / 2;
                        const y = PADDING + row * SPACING + SPACING / 2;
                        ctx.fillStyle = players[boxes[row][col]].bgColor;
                        ctx.fillRect(x - SPACING / 2 + DOT_RADIUS, y - SPACING / 2 + DOT_RADIUS, SPACING - DOT_RADIUS * 2, SPACING - DOT_RADIUS * 2);

                        // Draw owner letter
                        ctx.fillStyle = players[boxes[row][col]].color;
                        ctx.font = 'bold 24px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(players[boxes[row][col]].name.charAt(0).toUpperCase(), x, y);
                    }
                }
            }

            // Draw horizontal lines
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE - 1; col++) {
                    const x1 = PADDING + col * SPACING;
                    const y = PADDING + row * SPACING;
                    const x2 = PADDING + (col + 1) * SPACING;

                    if (horizontalLines[row][col] !== null) {
                        // Draw claimed line
                        ctx.strokeStyle = players[horizontalLines[row][col]].color;
                        ctx.lineWidth = LINE_WIDTH;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x1 + DOT_RADIUS, y);
                        ctx.lineTo(x2 - DOT_RADIUS, y);
                        ctx.stroke();
                    } else if (hoveredLine && hoveredLine.type === 'horizontal' && hoveredLine.row === row && hoveredLine.col === col) {
                        // Draw hover effect
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = LINE_WIDTH;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x1 + DOT_RADIUS, y);
                        ctx.lineTo(x2 - DOT_RADIUS, y);
                        ctx.stroke();
                    }
                }
            }

            // Draw vertical lines
            for (let row = 0; row < GRID_SIZE - 1; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const x = PADDING + col * SPACING;
                    const y1 = PADDING + row * SPACING;
                    const y2 = PADDING + (row + 1) * SPACING;

                    if (verticalLines[row][col] !== null) {
                        // Draw claimed line
                        ctx.strokeStyle = players[verticalLines[row][col]].color;
                        ctx.lineWidth = LINE_WIDTH;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x, y1 + DOT_RADIUS);
                        ctx.lineTo(x, y2 - DOT_RADIUS);
                        ctx.stroke();
                    } else if (hoveredLine && hoveredLine.type === 'vertical' && hoveredLine.row === row && hoveredLine.col === col) {
                        // Draw hover effect
                        ctx.strokeStyle = '#999';
                        ctx.lineWidth = LINE_WIDTH;
                        ctx.lineCap = 'round';
                        ctx.beginPath();
                        ctx.moveTo(x, y1 + DOT_RADIUS);
                        ctx.lineTo(x, y2 - DOT_RADIUS);
                        ctx.stroke();
                    }
                }
            }

            // Draw dots
            ctx.fillStyle = '#333';
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const x = PADDING + col * SPACING;
                    const y = PADDING + row * SPACING;

                    ctx.beginPath();
                    ctx.arc(x, y, DOT_RADIUS, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            // Handle touch or mouse
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Calculate scale
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function getClosestLine(x, y) {
            // Check horizontal lines
            for (let row = 0; row < GRID_SIZE; row++) {
                for (let col = 0; col < GRID_SIZE - 1; col++) {
                    const x1 = PADDING + col * SPACING;
                    const x2 = PADDING + (col + 1) * SPACING;
                    const lineY = PADDING + row * SPACING;

                    if (x >= x1 && x <= x2 && Math.abs(y - lineY) < LINE_HIT_WIDTH / 2) {
                        return { type: 'horizontal', row, col };
                    }
                }
            }

            // Check vertical lines
            for (let row = 0; row < GRID_SIZE - 1; row++) {
                for (let col = 0; col < GRID_SIZE; col++) {
                    const lineX = PADDING + col * SPACING;
                    const y1 = PADDING + row * SPACING;
                    const y2 = PADDING + (row + 1) * SPACING;

                    if (y >= y1 && y <= y2 && Math.abs(x - lineX) < LINE_HIT_WIDTH / 2) {
                        return { type: 'vertical', row, col };
                    }
                }
            }
            return null;
        }

        function handleInputMove(e) {
            if (e.type === 'touchmove') e.preventDefault(); // Prevent scrolling

            const pos = getEventPos(e);
            const found = getClosestLine(pos.x, pos.y);

            // Only update hover if line is not already taken
            let validHover = null;
            if (found) {
                const isTaken = found.type === 'horizontal'
                    ? horizontalLines[found.row][found.col] !== null
                    : verticalLines[found.row][found.col] !== null;
                if (!isTaken) {
                    validHover = found;
                }
            }

            if (JSON.stringify(validHover) !== JSON.stringify(hoveredLine)) {
                hoveredLine = validHover;
                canvas.style.cursor = validHover ? 'pointer' : 'default';
                draw();
            }
        }

        function handleInputDown(e) {
            if (e.type === 'touchstart') e.preventDefault();

            const pos = getEventPos(e);
            const found = getClosestLine(pos.x, pos.y);

            if (found) {
                makeMove(found.row, found.col, found.type);
            }
        }

        function makeMove(row, col, type) {
            const lineArray = type === 'horizontal' ? horizontalLines : verticalLines;

            if (lineArray[row][col] !== null) return;

            lineArray[row][col] = currentPlayer;

            const completedBoxes = checkForCompletedBoxes(row, col, type);

            if (completedBoxes.length === 0) {
                switchTurn();
            } else {
                completedBoxes.forEach(box => {
                    boxes[box.row][box.col] = currentPlayer;
                });
                scores[currentPlayer] += completedBoxes.length;
                updateDisplay();
                // Player keeps turn if they complete a box
            }

            hoveredLine = null;
            draw();
            checkGameEnd();
        }

        function checkForCompletedBoxes(row, col, type) {
            const completed = [];

            if (type === 'horizontal') {
                // Check box above
                if (row > 0 && isBoxComplete(row - 1, col)) {
                    completed.push({ row: row - 1, col: col });
                }
                // Check box below
                if (row < GRID_SIZE - 1 && isBoxComplete(row, col)) {
                    completed.push({ row: row, col: col });
                }
            } else {
                // Check box to the left
                if (col > 0 && isBoxComplete(row, col - 1)) {
                    completed.push({ row: row, col: col - 1 });
                }
                // Check box to the right
                if (col < GRID_SIZE - 1 && isBoxComplete(row, col)) {
                    completed.push({ row: row, col: col });
                }
            }

            return completed;
        }

        function isBoxComplete(row, col) {
            if (boxes[row][col] !== null) return false;

            return horizontalLines[row][col] !== null &&
                horizontalLines[row + 1][col] !== null &&
                verticalLines[row][col] !== null &&
                verticalLines[row][col + 1] !== null;
        }

        function switchTurn() {
            currentPlayer = (currentPlayer + 1) % numPlayers;
            updateTurnIndicator();
        }

        function updateTurnIndicator() {
            const indicator = document.getElementById('turnIndicator');

            indicator.textContent = `${players[currentPlayer].name}'s Turn`;
            indicator.style.backgroundColor = players[currentPlayer].bgColor;
            indicator.style.color = players[currentPlayer].color;

            // Update active state in scoreboard
            for (let i = 0; i < numPlayers; i++) {
                const scoreDiv = document.getElementById(`player${i + 1}Score`);
                if (i === currentPlayer) {
                    scoreDiv.classList.add('active');
                } else {
                    scoreDiv.classList.remove('active');
                }
            }
        }

        function checkGameEnd() {
            const totalBoxes = (GRID_SIZE - 1) * (GRID_SIZE - 1);
            const totalScore = scores.reduce((a, b) => a + b, 0);

            if (totalScore === totalBoxes) {
                showWinner();
            }
        }

        function showWinner() {
            const modal = document.getElementById('winnerModal');
            const content = document.getElementById('winnerContent');
            const winnerText = document.getElementById('winnerText');
            const finalScore = document.getElementById('finalScore');

            // Find max score
            let maxScore = -1;
            let winners = [];

            for (let i = 0; i < numPlayers; i++) {
                if (scores[i] > maxScore) {
                    maxScore = scores[i];
                    winners = [i];
                } else if (scores[i] === maxScore) {
                    winners.push(i);
                }
            }

            if (winners.length === 1) {
                const winner = players[winners[0]];
                winnerText.textContent = `ðŸ† ${winner.name} Wins!`;
                winnerText.style.color = winner.color;
            } else {
                winnerText.textContent = 'ðŸ¤ It\'s a Tie!';
                winnerText.style.color = '#666';
            }

            // Build score string
            let scoreStr = players.slice(0, numPlayers).map((p, i) => `${p.name}: ${scores[i]}`).join(' - ');
            finalScore.textContent = scoreStr;

            modal.classList.add('show');
        }

        function closeModal() {
            document.getElementById('winnerModal').classList.remove('show');
        }

        function resetGame() {
            currentPlayer = 0;
            scores = new Array(numPlayers).fill(0);

            // Re-run init to handle grid size changes
            initGame();
            closeModal();
        }

        // Initialize
        initGame();
    </script>
</body>

</html>